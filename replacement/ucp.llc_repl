#include "cache.h"
#include "ooo_cpu.h"

BLOCK ATD[NUM_CPUS][LLC_SET][LLC_WAY];
vector<uint32_t> ways_of_cpu(NUM_CPUS);
uint64_t miss_counter, hit_counter[NUM_CPUS][LLC_WAY], partion_interval = 5000000;
vector<vector<uint32_t>> PREV_WAY_OF_CPU(LLC_SET,vector<uint32_t>(NUM_CPUS,LLC_WAY/NUM_CPUS));
// FILE* file_name = fopen("input.txt","r");
FILE* output_Stats = fopen("output.txt","w");
#define SIZE_OF_SETS 64
unsigned rand_sets[SIZE_OF_SETS];


void CACHE::UMON_update(uint32_t cpu, uint32_t set_index, uint32_t way)
{
    for (uint32_t i = 0; i < NUM_WAY; i++)
    {
        if (ATD[cpu][set_index][i].lru < ATD[cpu][set_index][way].lru)
        {
            ATD[cpu][set_index][i].lru++;
        }
    }
    ATD[cpu][set_index][way].lru = 0; // promote to the MRU position
}

uint32_t CACHE::UMON_find_victim(uint32_t cpu, uint32_t set_index)
{
    uint32_t way = 0;

    // fill invalid line first
    for (way = 0; way < NUM_WAY; way++)
    {
        if (ATD[cpu][set_index][way].valid == false)
        {
            ATD[cpu][set_index][way].valid=true;

            DP(if (warmup_complete[cpu]) {
            cout << "[" << NAME << "] " << __func__ << " instr_id: " << instr_id << " invalid set: " << set << " way: " << way;
            cout << hex << " address: " << (full_addr>>LOG2_BLOCK_SIZE) << " victim address: " << ATD[cpu]k[set][way].address << " data: " << ATD[cpu][set][way].data;
            cout << dec << " lru: " << ATD[cpu][set][way].lru << endl; });

            break;
        }
    }

    // LRU victim
    if (way == NUM_WAY)
    {
        for (way = 0; way < NUM_WAY; way++)
        {
            if (ATD[cpu][set_index][way].lru == NUM_WAY - 1)
            {

                DP(if (warmup_complete[cpu]) {
                cout << "[" << NAME << "] " << __func__ << " instr_id: " << instr_id << " replace set: " << set << " way: " << way;
                cout << hex << " address: " << (full_addr>>LOG2_BLOCK_SIZE) << " victim address: " << block[set][way].address << " data: " << block[set][way].data;
                cout << dec << " lru: " << ATD[cpu][set][way].lru << endl; });
                break;
            }
        }
    }

    if (way == NUM_WAY)
    {
        cerr << "[" << NAME << "] " << __func__ << " no victim! set: " << set_index << endl;
        assert(0);
    }
    // cout<< "way = "<<way <<endl;
    return way;
}

uint64_t CACHE::get_utility(uint32_t cpu, uint32_t a)
{
    return hit_counter[cpu][a];
}

void CACHE::UMON(uint32_t cpu, uint64_t full_addr, uint32_t set)
{
    int found =0;
    for(int i=0;i<SIZE_OF_SETS;i++){
        if(rand_sets[i]  == set) found =1;
    }
    if(found ==0) return;
    uint32_t set_index = set;
    uint32_t way = 0;
    for (way = 0; way < NUM_WAY; way++)
    {
        if (ATD[cpu][set_index][way].valid and ATD[cpu][set_index][way].address == full_addr)
        {
            // if (warmup_complete[cpu])
            hit_counter[cpu][ATD[cpu][set_index][way].lru]++;
            break;
        }
    }
    if (way == NUM_WAY)
    {
        way = UMON_find_victim(cpu, set_index);
        // if (warmup_complete[cpu])
        miss_counter++;
    }
    ATD[cpu][set_index][way].address = full_addr;
    UMON_update(cpu, set_index, way);
    
}

void CACHE::make_partition()
{
    
    uint32_t balance = LLC_WAY - NUM_CPUS,prev_balance;
    prev_balance=balance;
    for (uint32_t i = 0; i < NUM_CPUS; i++)
        ways_of_cpu[i] = 1;
    while (balance)
    {
        uint32_t winner = 0;
        double final_max_utility = 0;
        uint32_t req_ways=0;
        for (uint32_t current_cpu = 0; current_cpu < NUM_CPUS; current_cpu++)
        {
            double max_utility = 0;
            uint32_t current_utility=0,current_ways=0;
            for (uint32_t i = ways_of_cpu[current_cpu]+1; i <= balance+ways_of_cpu[current_cpu]; i++)
            {
                current_utility += get_utility(current_cpu,i-1);
                double real_utility = 1.0 * current_utility/(i-ways_of_cpu[current_cpu]);
                if(real_utility>max_utility)
                {
                    max_utility=real_utility;
                    current_ways=i;
                }
            }
            if (max_utility > final_max_utility)
            {
                final_max_utility = max_utility;
                winner = current_cpu;
                req_ways=current_ways;
            }
        }
        if(req_ways<=0) req_ways = ways_of_cpu[winner];
        balance-=req_ways-ways_of_cpu[winner];
        ways_of_cpu[winner]=req_ways;
        if(prev_balance==balance) break;
        else prev_balance=balance;
    }
    ways_of_cpu[0]+=balance;
    for (uint32_t i = 0; i < NUM_CPUS; i++)
    {
        fprintf(output_Stats,"%d ",ways_of_cpu[i]);
    }
    fprintf(output_Stats," %d\n",partion_interval);

    
}

void CACHE::llc_initialize_replacement()
{
    srand(time(NULL));
    unsigned long rand_seed = 1;
    unsigned long max_rand = 1048576;
    uint32_t my_set = LLC_SET;
    int do_again = 0;
    for (int i=0; i<SIZE_OF_SETS; i++) {
        do {
            do_again = 0;
            rand_seed = rand_seed * 1103515245 + 12345;
            rand_sets[i] = ((unsigned) ((rand_seed/65536) % max_rand)) % my_set;
            for (int j=0; j<i; j++) {
                if (rand_sets[i] == rand_sets[j]) {
                    do_again = 1;
                    break;
                }
            }
        } while (do_again);
    }
    
    uint32_t DIVIDER = LLC_WAY/NUM_CPUS;
    for (uint32_t i=0; i<NUM_SET; i++) {    
        for (uint32_t j=0; j<NUM_WAY; j++) 
        {
            block[i][j].lru = j%DIVIDER;
            block[i][j].cpu = j/DIVIDER;
        }
    }
    for (uint32_t i = 0; i < NUM_CPUS; i++)
    {
        ways_of_cpu[i] = LLC_WAY / NUM_CPUS;
        for (uint32_t j = 0; j < LLC_SET; j++)
        {
            for (uint32_t k = 0; k < LLC_WAY; k++)
            {
                ATD[i][j][k].lru = k;
            }
        }
    }
}

// find replacement victim
uint32_t CACHE::llc_find_victim(uint32_t cpu, uint64_t instr_id, uint32_t set, const BLOCK *current_set, uint64_t ip, uint64_t full_addr, uint32_t type)
{
    uint32_t way = 0;

    if(PREV_WAY_OF_CPU[set][cpu]>=ways_of_cpu[cpu])
    {
        // fill invalid line first
        for (way = 0; way < NUM_WAY; way++)
        {
            if (block[set][way].valid == false && block[set][way].cpu == cpu)
            {
                DP(if (warmup_complete[cpu]) {
                cout << "[" << NAME << "] " << __func__ << " instr_id: " << instr_id << " invalid set: " << set << " way: " << way;
                cout << hex << " address: " << (full_addr>>LOG2_BLOCK_SIZE) << " victim address: " << block[set][way].address << " data: " << block[set][way].data;
                cout << dec << " lru: " << block[set][way].lru << endl; });

                break;
            }
        }

        // LRU victim
        if (way == NUM_WAY)
        {
            for (way = 0; way < NUM_WAY; way++)
            {
                if (block[set][way].lru == PREV_WAY_OF_CPU[set][cpu] - 1 && block[set][way].cpu == cpu)
                {

                    DP(if (warmup_complete[cpu]) {
                    cout << "[" << NAME << "] " << __func__ << " instr_id: " << instr_id << " replace set: " << set << " way: " << way;
                    cout << hex << " address: " << (full_addr>>LOG2_BLOCK_SIZE) << " victim address: " << block[set][way].address << " data: " << block[set][way].data;
                    cout << dec << " lru: " << block[set][way].lru << endl; });

                    break;
                }
            }
        }
    }
    else if(PREV_WAY_OF_CPU[set][cpu]<ways_of_cpu[cpu])
    {
        // fill invalid line first
        for (way = 0; way < NUM_WAY; way++)
        {
            if (block[set][way].valid == false && (block[set][way].cpu == cpu or PREV_WAY_OF_CPU[set][block[set][way].cpu]>ways_of_cpu[block[set][way].cpu]))
            {
                PREV_WAY_OF_CPU[set][block[set][way].cpu]--;
                block[set][way].cpu=cpu;
                block[set][way].lru=PREV_WAY_OF_CPU[set][cpu];
                PREV_WAY_OF_CPU[set][block[set][way].cpu]++;

                DP(if (warmup_complete[cpu]) {
                cout << "[" << NAME << "] " << __func__ << " instr_id: " << instr_id << " invalid set: " << set << " way: " << way;
                cout << hex << " address: " << (full_addr>>LOG2_BLOCK_SIZE) << " victim address: " << block[set][way].address << " data: " << block[set][way].data;
                cout << dec << " lru: " << block[set][way].lru << endl; });

                break;
            }
        }

        // LRU victim
        if (way == NUM_WAY)
        {
            for (way = 0; way < NUM_WAY; way++)
            {
                if (block[set][way].lru == PREV_WAY_OF_CPU[set][block[set][way].cpu] - 1 && block[set][way].cpu != cpu and PREV_WAY_OF_CPU[set][block[set][way].cpu]>ways_of_cpu[block[set][way].cpu])
                {
                    PREV_WAY_OF_CPU[set][block[set][way].cpu]--;
                    block[set][way].cpu=cpu;
                    block[set][way].lru=PREV_WAY_OF_CPU[set][cpu];
                    PREV_WAY_OF_CPU[set][block[set][way].cpu]++;

                    DP(if (warmup_complete[cpu]) {
                    cout << "[" << NAME << "] " << __func__ << " instr_id: " << instr_id << " replace set: " << set << " way: " << way;
                    cout << hex << " address: " << (full_addr>>LOG2_BLOCK_SIZE) << " victim address: " << block[set][way].address << " data: " << block[set][way].data;
                    cout << dec << " lru: " << block[set][way].lru << endl; });

                    break;
                }
            }
        }
        
    }

    if (way == NUM_WAY)
    {
        cerr << "[" << NAME << "] " << __func__ << " no victim! set: " << set << endl;
        assert(0);
    }

    return way;
}

void CACHE::ucp_update(uint32_t set, uint32_t way, uint32_t cpu)
{
    for (uint32_t i = 0; i < NUM_WAY; i++)
    {
        if (block[set][i].lru < block[set][way].lru && block[set][i].cpu ==  cpu)
        {
            block[set][i].lru++;
        }
    }
    block[set][way].lru = 0; // promote to the MRU position
}
// called on every cache hit and cache fill
void CACHE::llc_update_replacement_state(uint32_t cpu, uint32_t set, uint32_t way, uint64_t full_addr, uint64_t ip, uint64_t victim_addr, uint32_t type, uint8_t hit)
{
    string TYPE_NAME;
    if (type == LOAD)
        TYPE_NAME = "LOAD";
    else if (type == RFO)
        TYPE_NAME = "RFO";
    else if (type == PREFETCH)
        TYPE_NAME = "PF";
    else if (type == WRITEBACK)
        TYPE_NAME = "WB";
    else
        assert(0);

    if (hit)
        TYPE_NAME += "_HIT";
    else
        TYPE_NAME += "_MISS";

    if ((type == WRITEBACK) && ip)
        assert(0);


    // baseline LRU
    if (hit && (type == WRITEBACK)) // writeback hit does not update LRU state
        return;
    UMON(cpu, full_addr,set);
    if (current_core_cycle[0] >= partion_interval )
    {
        make_partition();
        partion_interval += 5000000;
        for (uint32_t i = 0; i < NUM_CPUS; i++)
        {
            for (uint32_t j = 0; j < LLC_WAY; j++)
                hit_counter[i][j] /= 2;
        }
    }
    return ucp_update(set, way, cpu);
}

void CACHE::llc_replacement_final_stats()
{
    fclose(output_Stats);
}
